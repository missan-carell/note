# bash学习

[toc] 

## 1.bash的概念

bash是shell的一种，shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序
用户可以用Shell来启动、挂起、停止甚至是编写一些程序。

用户通过发送命令，或[^脚本]给shell，通过shell的解释来运行该命令/脚本

shell功能图解：

![](.assets\image-20250225182614032.png)

### 1.1 shell的变量

shell的变量有两种，一种是系统变量，另一种为自定义变量，以下从这两点分别介绍：

#### 1.1.1 系统变量

如：$HOME、$PWD、$SHELL、$USER等等，是系统自带的变量,注意这些变量都需要**大写**

```
echo $HOME
/root
```

通过set指令，可以查看当前所有系统变量

#### 1.1.2 自定义变量

最常用的自定义变量，也就是自己可以给变量赋值

1. 基本语法定义变量:

- 变量名=值 ，中间**没有空格**
- 撤销变量:unset 
- 变量声明[^静态变量]:readonly B=1，注意:不能unset

#### 1.1.3 shell变量的规则

- 赋值规则：

  1. **变量名称**可以由字母、数字和下划线组成，但是<u>不能以数字开头</u>。5A=200(x)

  2. 等号两侧不能有空格

  3. 变量名称一般习惯为大写，这是规范

- 将**命令**的返回值赋给变量

  1. A=`date反引号 (一对反引号），运行里面的命令，并把结果返回给变量A

  2. A=$(date)等价于反引号

## 2. shell脚本的基础

### 2.1 脚本格式要求

1. 脚本以#!/bin/bash开头
   - 此处的bash可以替换成别的shell，意思是这个脚本是以哪个shell来执行的
2. 脚本需要有可执行权限

### 2.2 脚本的执行方式

脚本的常用执行方式

1. 方式1：输入脚本的绝对路径或相对路径

   ./hello.sh #相对路径
   /home/shcode/hello.sh # 绝对路径

   - 注:首先要赋予heloworld.sh 脚本的+x权限，再执行脚本

2. 方式2：sh+脚本

   sh hello.sh

   - 注：不用赋予脚本+x权限，直接执行即可。

创建，执行脚本：

```bash
# 在linux里运行

vim hello.sh # 创建脚本
#!/bin/bash 
echo "hello world"
# 保存后退出会发现，这个脚本没有可执行权限

# 方法1：
chmod u+x hello.sh # 为该脚本增加可执行权限
# 执行脚本
./hello.sh #相对路径
/home/shcode/hello.sh # 或用绝对路径

# 输出结果：hello world

# 方法2：
sh hello.sh # 不需要授权，直接执行
```

### 2.3 运算符

### 2.4 位置参数变量

当我们执行一个shel脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量
比如
./myshel.sh 100 200，这个就是一个执行shell的命令行，可以在myshell 脚本中获取到参数
信息。此处想要获取 myshel.sh 这个脚本里面的100和200的参数信息

- 注意：这里面的参数都**不可赋值**

1. 基本语法

   - $n 功能描述:  $n为数字，$0代表**命令本身**，$1-$9代表第一到第九个参数，十以上的参数，十以上的R灯参数需要用**大括号包含**，如${10}
   - ==$*==功能描述:  这个变量代表命令行中所有的参数，$*把所有的**参数看成一个整体**
     - 注意区分$@ ，两者执行效果很类似。区别案例可看 [3.3.2 for循环：](#3.3.2 for循环：)案例1
   - ==$@== 功能描述: 这个变量也代表命令行中所有的参数，不过$@把每**个参数区分对待**
   - $# 功能描述: 这个变量代表命令行中所有参数的**个数**

   ```bash
   #!/bin/bash
   echo "0=$0 , 1=$1 ,2=$2"
   echo "所有的参数 = $*"
   echo "$@"
   echo "参数的个数=$#"
   
   $ sh pos.sh 100 200 # 执行上述脚本，并带100和200这两个参数
   # 输出结果：
   0=pos.sh , 1=100 ,2=200
   # $0对应着执行的命令， $1 和 $2 分别是命令后面写的两个参数
   
   所有的参数 = 100 200
   # $* 表示，执行这个命令时，后面带的所有参数，且把参数看作整体
   
   100 200
   # $@ 同样表示所有参数，但是把参数分开对待
   
   参数的个数=2
   # $# 表示参数的个数
   ```

 

## 3. 编写脚本

### 3.1 基础语句

1. 输出：

```bash
echo "xx" # 输出xx，双引号可加可不加
echo $name # 引用变量，变量名称前要加$
echo "hello~$name" # 同时输出内容和变量，两者都要放在双引号里。
echo '$name' # 此时输出结果就不是变量name，而是$name本身
```

2. 为变量赋值：

``` bash
a=1
name="cat"
# 注意，变量和值之间不能有空格，字符串要加双引号，数值不用
files=$(ls) # 可以用$(命令) 来将变量内容定义为指定命令
A=`date` # 功能同上
unset 变量名 #撤销变量
```

3. 读取输入内容：

   ```bash
   read myname # 此处myname是可以自定义的变量
   missan # 此处要求用户输入内容，如 missan
   
   # 在输入内容前加入提示词
   read -p "Enter your name :" username
   # -p 指的是，系统会输出后面的提示词，username是用户需要输入内容的变量
   Enter your name : missan # missan是由用户自行输入的内容
   echo "hello!$username"
   hello!missan # 此时会返回username的变量
   ```

   

### 3.2 语句应用

1. 返回用户文件：

   ```bash
   #!/bin/bash
   files=$(ls)       # 将命令输出保存到变量
   read -p "Enter your name:" username
   echo "hello!$username,it's your files:"        # 使用变量要加$
   echo $files
   ```

2. 年龄判断：

   ```bash
   #!/bin/bash
   if [ $age -gt 18 ]
   then
           echo " 您已成年 "
   else
           echo " 您还未成年 "
   fi
   ```


3. 返回当前目录所有txt文件：

   ```bash
   for file in *txt # *txt的意思是遍历当前目录下所有的txt文件，此处也更换成其他内容
   do
   	echo "Processing $file" # 打印当前目录下所有txt文件的名称
   done
   
   #返回结果：
   Processing 1.txt
   Processing 2.txt
   ```


4. 位置参数的运用：

   ```bash
   if [ "$1" = "start" ]; then
     echo "正在启动服务..."
   elif [ "$1" = "stop" ]; then
     echo "正在停止服务..."
   fi
   ```

   


### 3.3 进阶语法

#### 3.3.1 条件判断：

1.  基础语法：

   注意：

   - 条件**非空**返回ture，可以用 $条件 来验证
   - 条件判断如果是空的，[  ] 里面依然要加**两个空格**，否则会报错

   ```bash
   if [ 条件 ] # 注意，条件前后有空格
   then
   	执行某命令
   fi # 结束条件判断
   
   # 判断ok是否等于ok
   if [ "ok" = "ok" ]
   then
           echo yes
   fi
   # 最后结果返回 yes，如果把一个ok换成ok2，则不会返回结果
   
   #判断 23是否大于22
   if [ 23 -gt 22 ]
   then
           echo yes
   fi
   # 结果返回 yes
   
   # 判断某文件夹下是否存在指定文件
   if [ -f /home/aa.txt ]
   then 
   	echo ok
   fi
   ```

2.  否则的使用：

   语法：

   ```bash
   if [ 条件 ]
   then 
   	执行什么
   else  # 这里表示，如果上面不正确，则执行此处命令
   	执行什么
   fi
   
   # 判断1是否大于2
   if [ 1 -gt 2 ]
   then
           echo yes
   else
   	echo no
   fi
   # 返回结果 no
   ```

   

3. **常用判断条件**

1）= 字符串比较

2）两个整数的比较
-lt 小于
-le 小于等于

-gt 大于

-eq 大于
-ge 大于等于
-ne 不等于

- **注：不要忘记带-**

3 ) 按照文件权限进行判断
-r 有读的权限
-w 有写的权限
-x 有执行的权限

4)按照文件类型进行判断
-f 判断文件存在并且是一个常规的文件
-e 判断文件是否存在

-d 判断目录是否存在

#### 3.3.2 for循环：

1. 基础语法1：

   ```bash
   #！/bash/bin
   for 变量 in 值1 值2 值3... # 意思是：变量在这些值的范围内，都可以执行循环
   do
   程序(代码)
   done # 结束
   
   # 案例1 区分$* 和$@
   #!/bin/bash
   for i in "$*"
   do
           echo "number is $i"
   
   sh for.sh 100 200 300
   echo ------------
   for j in "$*"
   do
           echo "number is $j"
   
   sh for.sh 100 200 300
   # 输出结果：
   number is 100 200 300
   ------------
   number is 100
   number is 200
   number is 300
   
   # 案例2 循环的简单运用
   #！/bin/bash
   for fruit in apple banna orange
   do
           echo "I like $fruit"
   done
   
   sh fruit.sh
   # 输出结果
   I like apple
   I like banna
   I like orange
   ```

   案例1 中可看出，$* 和 $@ 的区别：

   - $* 把参数看作一个整体，因此i在参数里相当于只有一个：“100 200 300”，所以循环只执行一次
   - $@ 把参数分开对待，因此依据上述原理，循环执行三次

2. 基础语法2：

   ```bash
   for((初始值;循环控制条件;变量变化 )) # 此处有两对空格
   do
   	程序
   done
   
   # 案例3 ：求1到100相加的总和
   #!/bin/bash
   sum=0
   for (( i=1; i<=100; i++)) # (( i++ ))是指i是一个自增长的量，即在循环里每次递增1
   do
           sum=$[$sum+$i]
   done
   echo "总和=$sum"
   
   # 案例4 ：求从1加到n的和，n自定义
   #!/bin/bash
   sum=0
   for (( i=1; i<=$1; i++)) # (( i++ ))是指i是一个自增长的量，即在循环里每次递增1
   # i<=$1 指的是，i的范围小于我输入的第一个参数，即从i的范围是[1-n]
   do
           sum=$[$sum+$i]
   done
   echo "总和=$sum"
   
   sh for2.sh 20
   # 输出结果
   总和是210
   ```
   

#### 3.3.3 awk的使用：

awk是shell中用于处理文本或者数据的脚本

1. 基本语法：

``` bash
awk -选项 'pattern {action}' 文件名
# pattern：是用于匹配输入数据的模式。如果省略，则 awk 将对所有行进行操作。
# {action}：是在匹配到模式的行上执行的动作。如果省略，则默认动作是打印整行。

# 案例：
# 1. 先新建一个测试文件，往里面输入内容：
vim ce
1 2 3
a;b;c
4.5.6
e:d:f
```

- 输出全部内容：

  ```bash
  # 直接输出全部内容：
  awk '{print}' ce
  awk '{print $0}' ce # $0 表示整行内容，同样可以达到输出全部的效果
  ```

- 用分隔符输出特定内容：

  ```bash
  # 不加参数：默认使用空格分割：
  awk '{print $1,$2}' ce
  1 2
  a;b;c
  4.5.6
  e:d:f
  # 第一行以空格分割的123，只节选了12，其他部分正常输出
  
  # 使用参数：规定一个分隔符
  awk -F';' '{print $1,$2}' ce 
  1 2 3 
  a b
  4.5.6 
  e:d:f 
  # 使用 -F+符号，来规定其他分割符号
  # 使用其他分隔符同理
  
  # 使用参数：规定多个分隔符
  awk -F '[ :]'  '{print $1,$2,$5}' ce
  1 2 
  a;b;c  
  4.5.6  
  e d 
  # 这里表示，先用空格分割，在用:分割
  awk -F '[;:]'  '{print $1,$2,$5}' ce
  1 2 3  
  a b 
  4.5.6  
  e d 
  # 或是先用；分割 ，在用：分割
  ```

- 显示行号：

  ```bash
  # 显示全部行号：使用NR， $0表示显示全部行号
  awk '{print NR, $0}' ce
  1 1 2 3
  2 a;b;c
  3 4.5.6
  4 e:d:f
  
  # 指定打印某一行：只打印第二行
  awk 'NR == 2 {print ,$0}' ce # 注意有两个等号
  a;b;c
  
  #跳过前n行：跳过前两行
  awk 'NR > 2 {print NR ,$0}' ce
  3 4.5.6
  4 e:d:f
  # 如果这里后面不加$0,则只会输出行号。若想避免，则去除{}内的NR
  
  # 统计一共几行
  awk 'END {print NR}' ce
  4
  # END意为：处理完所有行后执行
  ```

- 处理多个文件：NR 和 FNR的对比

  - **`NR`**：累计行号（处理多个文件时持续递增）。
  - **`FNR`**：单个文件的行号（处理多个文件时，每换一个文件会重置为1）。

  ```bash
  # NR 处理多个文件
  
  ```
  
  

-- 注：

- **awk以：空格/制表符分割字段**，第二个案例中，如果文本内容每行后面没有空格/制表符，则awk会认为整个文本内容属于一段，在输出的时候**只会输出整段内容**，达不到只显示某特定部分的效果, 如：

  ```bash
  vim a
  1
  2
  3
  awk '{print $1,$2}' a
  1
  2
  3 # 会全部输出
  ```

  

  

2. 选项：
   - `-F <分隔符>` 或 `--field-separator=<分隔符>`： 指定输入字段的分隔符，默认是空格。使用这个选项可以指定不同于默认分隔符的字段分隔符。
   - `-v <变量名>=<值>`： 设置 `awk` 内部的变量值。可以使用该选项将外部值传递给 `awk` 脚本中的变量。
   - `-f <脚本文件>`： 指定一个包含 `awk` 脚本的文件。这样可以在文件中编写较大的 `awk` 脚本，然后通过 `-f` 选项将其加载。
   - `-V` 或 `--version`： 显示 `awk` 的版本信息。
   - `-h` 或 `--help`： 显示 `awk` 的帮助信息，包括选项和用法示例

### 3.4 函数

#### 3.4.1 系统函数

系统函数有很多，此处只记录一些比较实用的函数

1. basename 用于返回完整路径最后 / 后的部分，常用于获取文件名

   - 注意：最后这个文件，不需要真的存在，也会返回结果

   ```bash
   basename /home/test/a.txt
   # 返回结果 ： a.txt
   
   # 如果在文件名后面带上后缀，则返回结果会去除文件名
   basename /home/test/a.txt .txt
   #返回结果：a
   ```

2. dirname  返回完整路径 / 前所有的内容，一般用于获取路径

   ```bash
   dirname /home/test/a.txt
   # 返回结果：/home/test
   ```

#### 3.4.2 ==自定义函数==

1. 基础语法：

   注：

   - 函数名称尽量避免与系统函数冲突：ls，pwd等
   - 自定义函数**只能在脚本**里面调用

   ```bash
   function 函数名称() {  # function可加可不加
   	函数内容(命令)
   }
   
   函数名 [值] # 调用函数，值根据需要是否填写
   ```

   

1. 案例1 ：加法函数

   ```bash
   function getSum() {  # 定义函数名：getSum
   	SUM=$[$n1+$n2]  
   	echo "相加的和 = $SUM " 
   	# 函数内容：变量n1 和n2相加，然后返回结果
   }
   
   # 通过控制台输入值
   read -p "请输入要相加的数子,n1=" n1 
   read -p "请输入要相加的数子,n2=" n2
   # 调用函数
   getSum $n1 $n2
   
   # 返回结果：
   请输入要相加的数子,n1=250
   请输入要相加的数子,n2=270         
   相加的和 = 520 
   ```

   2. 案例2：打招呼函数

   ```bash
   greet(){
   	echo "hello,$1"
   }
   greet(){
   	echo "hello,$1"
   }
   
   read -p "请输入用户名：" username
   greet $username
   
   ```

   









[^脚本]: 用于存放大块的命令，一起执行，一般shell脚本的后缀是.sh
[^静态变量]: 不可被反复定义，只能定义一次的变量
